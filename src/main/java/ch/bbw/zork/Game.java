package ch.bbw.zork;import java.util.ArrayList;import java.util.Scanner; // Importiert die Klasse Scanner | Scanner ist eine Klasse, die es erlaubt Benutzereingaben einzulesen zu können.import java.util.Stack; // Importiert die Java Klasse "Stack" | Stack ist ein Stapelspeicher, wie z.B ein Stapel Karten | Das Prinip nennt man LIFO Last in, First out | Heisst das was du zuletzt auf den Stack legst, das holst du auch als erstes wieder/** * Class Game - the main class of the "Zork" game. * * Author:  Michael Kolling, 1.1, March 2000 * refactoring: Rinaldo Lanza, September 2020 */public class Game { // Öffentliche Klasse Names "Game"	private Parser parser; // Attribut "parser" speichert Klasse Parser | Parser hat eigentlich die Aufgabe die Eingaben in Befehle umzuwandeln	private Room currentRoom; // Attribut "currentRoom" speichert Klasse Room | Klasse Room definiert einen Raum	private Room keller, speisesall, bibliothek, geheimgang, schlafgemach, galerie, garten; // Noch weitere Attribute speichern einen Raum beziehungsweise die Klasse Room, heisst wir speichern den aussenRaum das Office etc ...	private Stack<Room> history = new Stack<>(); // In "history" wird ein neuer Stack gespeichert, also ein Stapelspeicher der Room Objekte speichern kann.	private ArrayList<Room> allRooms = new ArrayList<>(); // In "allRooms" wird eine neue Arrayliste gespeichert die Room Objekte speichern kann.	private Player player; // Attribut "player" ist privat | Speichert ein Objekt von der Klasse Player | Das Attribut zeigt später ein Objekt vom Typ Player	public Game() { // Konstruktor von dieser "Game" Klasse, wird ausgeführt wenn man eines neues "Game" Objekt erstellt		parser = new Parser(System.in); // Heisst man erstellt ein neues Parser-Objekt das mit System.in arbeitet also mit der Tastatur ab hier wird also auf die Tastatur gehört		createRooms(); // "createRooms" Methode wird aufgerufen | "createRooms" sind die Räume und der GewinnerRaum		player = new Player(); // Neues Spieler Objekt wird erstellt und in "player" gespeichert | Jetzt ist das Attribut "player" mit einem Objekt gefüllt	}	private void createRooms() { // Private Methode | Gibt nichts zurück darum void | Name createRooms		keller = new Room("im dunklen, feuchten Keller"); // Neues Room Objekt wird erstellt mit einer gewissen Beschreibung und variable "keller" speichert das ganze		speisesall = new Room("im Speisesall mit langem Tisch");		bibliothek = new Room("in der staubigen Bibliothek");		geheimgang = new Room("in einem geheimen, engen Gang");		schlafgemach = new Room("im königlichen Schlafgemach");		galerie = new Room("in der zerfallenen Galerie");		garten = new Room("im überwucherten Schlossgarten"); // das hier ist übrigens der GewinnerRaum		allRooms.add(keller); // Zu der allRooms Arrayliste wird der Keller hinzugefügt		allRooms.add(speisesall);		allRooms.add(bibliothek);		allRooms.add(geheimgang);		allRooms.add(schlafgemach);		allRooms.add(galerie);		allRooms.add(garten);		keller.setExits(null, speisesall, null, null); // Wir nehmen den keller Raum und rüfen damit die "setExits" Methode auf und übergeben diese 4 Sachen | Heisst vom Keller geht es nur in Richtung Osten dort kommt man in den Speisesall		speisesall.setExits(null, bibliothek, null, keller);		bibliothek.setExits(null, geheimgang, null, speisesall);		geheimgang.setExits(null, schlafgemach, null, bibliothek);		schlafgemach.setExits(null, galerie, null, geheimgang);		galerie.setExits(null, garten, null, schlafgemach);		garten.setExits(null, null, null, galerie);		garten.setWinningRoom(true); // Garten Objekt wird mit setWinninngRoom Methode aufgerufen und sagt das garten true ist also der GewinnerRaum		Item schluessel = new Item("Schlüssel", "Ein rostiger alter Schlüssel." ,2 ); // schluessel hat den Typ Item unnd speichert ein neues Item Objekt mit einem bestimmten namen und einer bestimmten Beschreibung		Item eimer = new Item ("Eimer", "Ein verbeulter Metalleimer.", 4);		Item teller = new Item("Teller", "Ein goldverzierter Porzellanteller.", 4);		Item kerzenstaender = new Item("Kerzenständer", "Ein schwerer Leuchter aus Eisen.", 3);		Item buch = new Item("Buch", "Ein altes Tagebuch mit geheimem Wissen.", 3);		Item feder = new Item("Feder", "Eine elegante Schreibfeder mit Tinte.", 1);		Item fackel = new Item("Fackel", "Eine brennbare Fackel.", 1);		Item seil = new Item("Seil", "Ein langes Kletterseil.", 1);		Item kissen = new Item("Kissen", "Ein seidenweiches Kopfkissen.", 2);		Item krone = new Item("Krone", "Eine funkelnde Kinderkrone.", 2);		Item gemaelde = new Item("Gemälde", "Ein beschädigtes königliches Porträt.", 5);		Item spiegel = new Item("Spiegel", "Ein zerbrochener Handspiegel.", 5);		Item blume = new Item("Blume", "Eine leuchtende Blume mit magischem Duft.", 1);		Item brunnen = new Item("Brunnen", "Ein verwunschener Brunnen mit klarem Wasser.", 6);		keller.addItem(schluessel); // Für das Room Objekt Keller wird ein item hinzugefügt nämlicher der Schlüssel | Dabei wird addItem Methode wird aufgerufen und der Schlüssel wird übergeben und am Schluss landet dieser in der ArrayListe		keller.addItem(eimer);		speisesall.addItem(teller);		speisesall.addItem(kerzenstaender);		bibliothek.addItem(buch);		bibliothek.addItem(feder);		geheimgang.addItem(fackel);		geheimgang.addItem(seil);		schlafgemach.addItem(kissen);		schlafgemach.addItem(krone);		galerie.addItem(gemaelde);		galerie.addItem(spiegel);		garten.addItem(blume);		garten.addItem(brunnen);		currentRoom = keller; // Anfangs Raum ist der Keller | currentRoom hat den Wert vom Keller	}	/**	 * Main play routine.  Loops until end of play.	 */	public void play() { // Public Methode | Keine Rückgabe | Namens play		printWelcome(); // printWelcome Methode wird aufgerufen		// Enter the main command loop.  Here we repeatedly read commands and		// execute them until the game is over.		boolean finished = false; // "finished" Variabel hat den Wert falsch		while (!finished) { // solange finished negativ ist also false:			Command command = parser.getCommand(); // fragst den Parser nach dem command, welcher der Spieler eingegeben hat übrigens mussen zuerst command mit Command Klasse deklarieren			finished = processCommand(command); // "processCommand" Methode wird aufgerufen und der command wird übergeben, Rückgabe true oder false wird in finished gespeichert		}		System.out.println("Thank you for playing. Good bye"); // Wenn Spiel vorbei ist kommt dieser text	}	private void printWelcome() { // Private Methode | ohne Rückgabe | Names printWelcome		System.out.println(); // LeerZeile		System.out.println("Willkommen im Schloss-Abenteuer!");		System.out.println("Ziel: Finde den Garten.");		System.out.println(); // LeerZeile		System.out.println(currentRoom.longDescription());	}	private boolean processCommand(Command command) { // Private Boolean Methode heisst Rückgabe true oder false | Nimmt als parameter denn "command" mit dem Typ "Command" indem Fall die Klasse		if (command.isUnknown()) { // wenn command nicht bekannt ist			System.out.println("Ich verstehe das Kommando nicht...");			return false;		}		String commandWord = command.getCommandWord(); // Holt das Kommando-Wort (z. B. "go", "help") aus dem Command-Objekt. | Speichert es in der String-Variable "commandWord".		switch (commandWord) { // mit switch und case variabel überprüfen in diesem Fall das Kommando-Wort			case "help": // Wenn Kommando-Wort "help" dann:				printHelp(); // Print-Help Funktion wird ausgeführt				break; // dann abbrechen damit die anderen cases nicht ausgeführt werden zur Sicherheit			case "go": // Wenn Kommando-Wort "go" dann:				goRoom(command); // goRoom Funktion wird aufgerufen und ganzes command Objekt wird mitgegeben				break;			case "take": // Wenn Kommando Wort "take" dann:				takeItem(command); // takeItem Methode wird aufgerufen und das command Objekt wird mitgegeben				break; // damit nur ein case von denen aufgerufen wird und nachher Abbruch			case "inventory": // Wennn KommandoWort "inventory" dann:				playerInventory(); // Diese Methode wird aufgerufen, in der Methode wird das Inventar angezeigt				break; // damit nur ein case von denen aufgerufen wird und nachher Abbruch			case "back":				goBack();				break;			case "map":				printMap();				break;			case "quit": // Wenn Kommando-Wort "quit" dann:				if (command.hasSecondWord()) { // Wenn command Objekt ein zweites Wort hat dann:					System.out.println("Was beenden?"); // Gibt das aus				} else {					return true; // signal that we want to quit und Methode wird auch beendet				}				break;			default: // Wenn keiner von den cases dann:				System.out.println("Unbekannter Fehler"); // Gibt das aus		}		return false; // in allen anderen Fälle soll das Spiel weitergehen darum false	}	private void printHelp() { // Private Methode ohne Rückgabe names printHelp Hilfversuche wenn man "help" eingibt		System.out.println("Du bist verloren im alten Schloss...");		System.out.println("Mögliche Befehle: go, quit, help");		System.out.println(parser.showCommands()); // Commands zeigen	}	private void goRoom(Command command) { // Private Methode ohne Rückgabe names goRoom und mann bekommt das Objekt command von der Klasse Command enthält z.B go north		if (!command.hasSecondWord()) { // Wenn command Objekt kein zweites Word dann:			System.out.println("Wohin möchtest du gehen?"); // Diese Nachricht		}		String direction = command.getSecondWord(); // in der String Variabel "direction" wird das zweite Wort von dem command Objekt gespeichert		Room nextRoom = currentRoom.nextRoom(direction); // in der Variabel von der Klasse Room namens nextRoom speichert den nächstens Raum der in dieser Richtung liegt |ruft nextRoom methode auf mit dem aktuellen Raum davon die direction auch		if (nextRoom == null) { // Wenn nextRoom gleich 0 null ist			System.out.println("Dort ist keine Tür");		} else { // Wenn der Raum nicht gleich 0 ist			history.push(currentRoom); // Bevor man wechselt noch den vorherigen Raum in den history Stack hineinpushen			currentRoom = nextRoom; // der aktuelle Raum hat jetzt den Wert vom nächsten Raum			System.out.println(currentRoom.longDescription()); // Die etwas längere beschreibung des akuellen Raumes wird asugegbene			if (currentRoom.isWinningRoom()) { // wenn der aktuelle Raum der Gewinner Raum ist:				System.out.println("🎉 Du hast den Garten erreicht und das Spiel gewonnen!");				System.exit(0); // Konsole wird geschlossen, laufendes Programm wird beendet			}		}	}	private void takeItem(Command command) { // Private Methode | ohne Rückgabe namens "takeItem" | Als Parameter nimmt er ein command Objekt von der Klasse/Typ Command		if(!command.hasSecondWord()) { // wenn command Objekt kein zweites Wort hat dann:			System.out.println("Was möchtest du aufheben"); // dieser Text		}		String itemName = command.getSecondWord(); // String Variable "itemName" hat den wert von dem zweiten Wort von dem command Objekt		Item found = null; // Vom Typ Item hat die Variable "found" wird mit null initalisiert | Heisst "found" verweist aktuell noch auf kein Item-Objekt | null bedeutet kein Objekt		for (Item item : currentRoom.getItems()) { // Für jedes item Objekt von Typ item was im aktuellen Raum ist | Durchläuft alle Items die mit currentRoom.getItems			if (item.getName().contentEquals(itemName)) { // Wenn der Name des Items gleich ist wie das 2 Wort vom Kommando dann: | Beispiel -> take Schlüssel , Schlüssel ist dann itemName				found = item; // found bekommt den Wert vom Item				break; // rausgehen			}		}		if (found != null) { // wenn "found" Variabel nicht gleich 0 dann:			currentRoom.getItems().remove(found); // Entfernst das Item aus der Item Liste mit .remove | Weil das jetzt beim Spieler ist nicht mehr im Raum			player.takeItem(found); // wichtig takeItem ist die Methode aus der Player Klasse gmeint | Sie wird richtig aufgerufen, weil player ja ein Objekt von der Klasse Player ist. Dabei wird das Item mitgegeben		}		else { // Wenn Variable "found" null ist dann:			System.out.println("Dieser Gegenstand ist nicht hier.");		}	}	private void playerInventory() { // Private Methode ohne Rückgabe names "playerIventory"		System.out.println(player.showInventory()); // Ausgabe von dem player Objekt die showInventory Methode aufrufen. Also eigentlich das Inventar vom Spieler ausgeben	}	private void goBack() { // Private Methode ohne Rückgabe names "goBack"		if(history.isEmpty()) { // Wenn der history stack leer ist dann:			System.out.println("Du kannst nicht zurück – du bist am Anfang.");		}		else { // Wenn history stack nicht leer			currentRoom = history.pop(); // der aktuelle Raum bekommt den Wert von dem hisory Stack | Und zwar das oberste Objekt vom Stapel und entfernt es gleichzeitig vom stack mit .pop			System.out.println("Du gehst zurück.");			System.out.println(currentRoom.longDescription()); // Längere Beschreibung des aktuellen Raums.		}	}	private void printMap() {		System.out.println("🗺 Raumübersicht:\n");		for (Room room : allRooms) { // Für jedes room Objekt was den Typ Room hat und in der allRooms Arrayliste ist:			String name = room.shortDescription(); // Die String Variable "name" hat den Wert von der methode shortDescripition, die in der Klasse Room ist | diese gibt die Beschreibung zurück			if (room == currentRoom) { // Wenn das room Objekt gleich der aktuelle Raum ist dann:				name += " ← du bist hier"; // Name bekommt neuen Wert name = name + " ← du bist hier";			}			System.out.println("- " + name); // Ausgabe			if (!room.getItems().isEmpty()) { // Wenn von einem der Räume die Item liste nicht leer ist:				for (Item item: room.getItems()) { // Für jedes item Objekt vom Typ Item was in der arrayliste items ist beziehungsweise in der Methode getItems() von der Room Klasse:					System.out.println("   → " + item); // Diese Ausgabe				}			}		}	}}