package ch.bbw.zork;import java.util.ArrayList;import java.util.Scanner; // Importiert die Klasse Scanner | Scanner ist eine Klasse, die es erlaubt Benutzereingaben einzulesen zu k√∂nnen.import java.util.Stack; // Importiert die Java Klasse "Stack" | Stack ist ein Stapelspeicher, wie z.B ein Stapel Karten | Das Prinip nennt man LIFO Last in, First out | Heisst das was du zuletzt auf den Stack legst, das holst du auch als erstes wieder/** * Class Game - the main class of the "Zork" game. * * Author:  Michael Kolling, 1.1, March 2000 * refactoring: Rinaldo Lanza, September 2020 */public class Game { // √ñffentliche Klasse Names "Game"	private Parser parser; // Attribut "parser" speichert Klasse Parser | Parser hat eigentlich die Aufgabe die Eingaben in Befehle umzuwandeln	private Room currentRoom; // Attribut "currentRoom" speichert Klasse Room | Klasse Room definiert einen Raum	private Room keller, speisesall, bibliothek, geheimgang, schlafgemach, galerie, garten; // Noch weitere Attribute speichern einen Raum beziehungsweise die Klasse Room, heisst wir speichern den aussenRaum das Office etc ...	private Stack<Room> history = new Stack<>(); // In "history" wird ein neuer Stack gespeichert, also ein Stapelspeicher der Room Objekte speichern kann.	private ArrayList<Room> allRooms = new ArrayList<>(); // In "allRooms" wird eine neue Arrayliste gespeichert die Room Objekte speichern kann.	private Player player; // Attribut "player" ist privat | Speichert ein Objekt von der Klasse Player | Das Attribut zeigt sp√§ter ein Objekt vom Typ Player	public Game() { // Konstruktor von dieser "Game" Klasse, wird ausgef√ºhrt wenn man eines neues "Game" Objekt erstellt		parser = new Parser(System.in); // Heisst man erstellt ein neues Parser-Objekt das mit System.in arbeitet also mit der Tastatur ab hier wird also auf die Tastatur geh√∂rt		createRooms(); // "createRooms" Methode wird aufgerufen | "createRooms" sind die R√§ume und der GewinnerRaum		player = new Player(); // Neues Spieler Objekt wird erstellt und in "player" gespeichert | Jetzt ist das Attribut "player" mit einem Objekt gef√ºllt	}	private void createRooms() { // Private Methode | Gibt nichts zur√ºck darum void | Name createRooms		keller = new Room("im dunklen, feuchten Keller"); // Neues Room Objekt wird erstellt mit einer gewissen Beschreibung und variable "keller" speichert das ganze		speisesall = new Room("im Speisesall mit langem Tisch");		bibliothek = new Room("in der staubigen Bibliothek");		geheimgang = new Room("in einem geheimen, engen Gang");		schlafgemach = new Room("im k√∂niglichen Schlafgemach");		galerie = new Room("in der zerfallenen Galerie");		garten = new Room("im √ºberwucherten Schlossgarten"); // das hier ist √ºbrigens der GewinnerRaum		allRooms.add(keller); // Zu der allRooms Arrayliste wird der Keller hinzugef√ºgt		allRooms.add(speisesall);		allRooms.add(bibliothek);		allRooms.add(geheimgang);		allRooms.add(schlafgemach);		allRooms.add(galerie);		allRooms.add(garten);		keller.setExits(null, speisesall, null, null); // Wir nehmen den keller Raum und r√ºfen damit die "setExits" Methode auf und √ºbergeben diese 4 Sachen | Heisst vom Keller geht es nur in Richtung Osten dort kommt man in den Speisesall		speisesall.setExits(null, bibliothek, null, keller);		bibliothek.setExits(null, geheimgang, null, speisesall);		geheimgang.setExits(null, schlafgemach, null, bibliothek);		schlafgemach.setExits(null, galerie, null, geheimgang);		galerie.setExits(null, garten, null, schlafgemach);		garten.setExits(null, null, null, galerie);		garten.setWinningRoom(true); // Garten Objekt wird mit setWinninngRoom Methode aufgerufen und sagt das garten true ist also der GewinnerRaum		Item schluessel = new Item("Schl√ºssel", "Ein rostiger alter Schl√ºssel." ,2 ); // schluessel hat den Typ Item unnd speichert ein neues Item Objekt mit einem bestimmten namen und einer bestimmten Beschreibung		Item eimer = new Item ("Eimer", "Ein verbeulter Metalleimer.", 4);		Item teller = new Item("Teller", "Ein goldverzierter Porzellanteller.", 4);		Item kerzenstaender = new Item("Kerzenst√§nder", "Ein schwerer Leuchter aus Eisen.", 3);		Item buch = new Item("Buch", "Ein altes Tagebuch mit geheimem Wissen.", 3);		Item feder = new Item("Feder", "Eine elegante Schreibfeder mit Tinte.", 1);		Item fackel = new Item("Fackel", "Eine brennbare Fackel.", 1);		Item seil = new Item("Seil", "Ein langes Kletterseil.", 1);		Item kissen = new Item("Kissen", "Ein seidenweiches Kopfkissen.", 2);		Item krone = new Item("Krone", "Eine funkelnde Kinderkrone.", 2);		Item gemaelde = new Item("Gem√§lde", "Ein besch√§digtes k√∂nigliches Portr√§t.", 5);		Item spiegel = new Item("Spiegel", "Ein zerbrochener Handspiegel.", 5);		Item blume = new Item("Blume", "Eine leuchtende Blume mit magischem Duft.", 1);		Item brunnen = new Item("Brunnen", "Ein verwunschener Brunnen mit klarem Wasser.", 6);		keller.addItem(schluessel); // F√ºr das Room Objekt Keller wird ein item hinzugef√ºgt n√§mlicher der Schl√ºssel | Dabei wird addItem Methode wird aufgerufen und der Schl√ºssel wird √ºbergeben und am Schluss landet dieser in der ArrayListe		keller.addItem(eimer);		speisesall.addItem(teller);		speisesall.addItem(kerzenstaender);		bibliothek.addItem(buch);		bibliothek.addItem(feder);		geheimgang.addItem(fackel);		geheimgang.addItem(seil);		schlafgemach.addItem(kissen);		schlafgemach.addItem(krone);		galerie.addItem(gemaelde);		galerie.addItem(spiegel);		garten.addItem(blume);		garten.addItem(brunnen);		currentRoom = keller; // Anfangs Raum ist der Keller | currentRoom hat den Wert vom Keller	}	/**	 * Main play routine.  Loops until end of play.	 */	public void play() { // Public Methode | Keine R√ºckgabe | Namens play		printWelcome(); // printWelcome Methode wird aufgerufen		// Enter the main command loop.  Here we repeatedly read commands and		// execute them until the game is over.		boolean finished = false; // "finished" Variabel hat den Wert falsch		while (!finished) { // solange finished negativ ist also false:			Command command = parser.getCommand(); // fragst den Parser nach dem command, welcher der Spieler eingegeben hat √ºbrigens mussen zuerst command mit Command Klasse deklarieren			finished = processCommand(command); // "processCommand" Methode wird aufgerufen und der command wird √ºbergeben, R√ºckgabe true oder false wird in finished gespeichert		}		System.out.println("Thank you for playing. Good bye"); // Wenn Spiel vorbei ist kommt dieser text	}	private void printWelcome() { // Private Methode | ohne R√ºckgabe | Names printWelcome		System.out.println(); // LeerZeile		System.out.println("Willkommen im Schloss-Abenteuer!");		System.out.println("Ziel: Finde den Garten.");		System.out.println(); // LeerZeile		System.out.println(currentRoom.longDescription());	}	private boolean processCommand(Command command) { // Private Boolean Methode heisst R√ºckgabe true oder false | Nimmt als parameter denn "command" mit dem Typ "Command" indem Fall die Klasse		if (command.isUnknown()) { // wenn command nicht bekannt ist			System.out.println("Ich verstehe das Kommando nicht...");			return false;		}		String commandWord = command.getCommandWord(); // Holt das Kommando-Wort (z.‚ÄØB. "go", "help") aus dem Command-Objekt. | Speichert es in der String-Variable "commandWord".		switch (commandWord) { // mit switch und case variabel √ºberpr√ºfen in diesem Fall das Kommando-Wort			case "help": // Wenn Kommando-Wort "help" dann:				printHelp(); // Print-Help Funktion wird ausgef√ºhrt				break; // dann abbrechen damit die anderen cases nicht ausgef√ºhrt werden zur Sicherheit			case "go": // Wenn Kommando-Wort "go" dann:				goRoom(command); // goRoom Funktion wird aufgerufen und ganzes command Objekt wird mitgegeben				break;			case "take": // Wenn Kommando Wort "take" dann:				takeItem(command); // takeItem Methode wird aufgerufen und das command Objekt wird mitgegeben				break; // damit nur ein case von denen aufgerufen wird und nachher Abbruch			case "inventory": // Wennn KommandoWort "inventory" dann:				playerInventory(); // Diese Methode wird aufgerufen, in der Methode wird das Inventar angezeigt				break; // damit nur ein case von denen aufgerufen wird und nachher Abbruch			case "back":				goBack();				break;			case "map":				printMap();				break;			case "quit": // Wenn Kommando-Wort "quit" dann:				if (command.hasSecondWord()) { // Wenn command Objekt ein zweites Wort hat dann:					System.out.println("Was beenden?"); // Gibt das aus				} else {					return true; // signal that we want to quit und Methode wird auch beendet				}				break;			default: // Wenn keiner von den cases dann:				System.out.println("Unbekannter Fehler"); // Gibt das aus		}		return false; // in allen anderen F√§lle soll das Spiel weitergehen darum false	}	private void printHelp() { // Private Methode ohne R√ºckgabe names printHelp Hilfversuche wenn man "help" eingibt		System.out.println("Du bist verloren im alten Schloss...");		System.out.println("M√∂gliche Befehle: go, quit, help");		System.out.println(parser.showCommands()); // Commands zeigen	}	private void goRoom(Command command) { // Private Methode ohne R√ºckgabe names goRoom und mann bekommt das Objekt command von der Klasse Command enth√§lt z.B go north		if (!command.hasSecondWord()) { // Wenn command Objekt kein zweites Word dann:			System.out.println("Wohin m√∂chtest du gehen?"); // Diese Nachricht		}		String direction = command.getSecondWord(); // in der String Variabel "direction" wird das zweite Wort von dem command Objekt gespeichert		Room nextRoom = currentRoom.nextRoom(direction); // in der Variabel von der Klasse Room namens nextRoom speichert den n√§chstens Raum der in dieser Richtung liegt |ruft nextRoom methode auf mit dem aktuellen Raum davon die direction auch		if (nextRoom == null) { // Wenn nextRoom gleich 0 null ist			System.out.println("Dort ist keine T√ºr");		} else { // Wenn der Raum nicht gleich 0 ist			history.push(currentRoom); // Bevor man wechselt noch den vorherigen Raum in den history Stack hineinpushen			currentRoom = nextRoom; // der aktuelle Raum hat jetzt den Wert vom n√§chsten Raum			System.out.println(currentRoom.longDescription()); // Die etwas l√§ngere beschreibung des akuellen Raumes wird asugegbene			if (currentRoom.isWinningRoom()) { // wenn der aktuelle Raum der Gewinner Raum ist:				System.out.println("üéâ Du hast den Garten erreicht und das Spiel gewonnen!");				System.exit(0); // Konsole wird geschlossen, laufendes Programm wird beendet			}		}	}	private void takeItem(Command command) { // Private Methode | ohne R√ºckgabe namens "takeItem" | Als Parameter nimmt er ein command Objekt von der Klasse/Typ Command		if(!command.hasSecondWord()) { // wenn command Objekt kein zweites Wort hat dann:			System.out.println("Was m√∂chtest du aufheben"); // dieser Text		}		String itemName = command.getSecondWord(); // String Variable "itemName" hat den wert von dem zweiten Wort von dem command Objekt		Item found = null; // Vom Typ Item hat die Variable "found" wird mit null initalisiert | Heisst "found" verweist aktuell noch auf kein Item-Objekt | null bedeutet kein Objekt		for (Item item : currentRoom.getItems()) { // F√ºr jedes item Objekt von Typ item was im aktuellen Raum ist | Durchl√§uft alle Items die mit currentRoom.getItems			if (item.getName().contentEquals(itemName)) { // Wenn der Name des Items gleich ist wie das 2 Wort vom Kommando dann: | Beispiel -> take Schl√ºssel , Schl√ºssel ist dann itemName				found = item; // found bekommt den Wert vom Item				break; // rausgehen			}		}		if (found != null) { // wenn "found" Variabel nicht gleich 0 dann:			currentRoom.getItems().remove(found); // Entfernst das Item aus der Item Liste mit .remove | Weil das jetzt beim Spieler ist nicht mehr im Raum			player.takeItem(found); // wichtig takeItem ist die Methode aus der Player Klasse gmeint | Sie wird richtig aufgerufen, weil player ja ein Objekt von der Klasse Player ist. Dabei wird das Item mitgegeben		}		else { // Wenn Variable "found" null ist dann:			System.out.println("Dieser Gegenstand ist nicht hier.");		}	}	private void playerInventory() { // Private Methode ohne R√ºckgabe names "playerIventory"		System.out.println(player.showInventory()); // Ausgabe von dem player Objekt die showInventory Methode aufrufen. Also eigentlich das Inventar vom Spieler ausgeben	}	private void goBack() { // Private Methode ohne R√ºckgabe names "goBack"		if(history.isEmpty()) { // Wenn der history stack leer ist dann:			System.out.println("Du kannst nicht zur√ºck ‚Äì du bist am Anfang.");		}		else { // Wenn history stack nicht leer			currentRoom = history.pop(); // der aktuelle Raum bekommt den Wert von dem hisory Stack | Und zwar das oberste Objekt vom Stapel und entfernt es gleichzeitig vom stack mit .pop			System.out.println("Du gehst zur√ºck.");			System.out.println(currentRoom.longDescription()); // L√§ngere Beschreibung des aktuellen Raums.		}	}	private void printMap() {		System.out.println("üó∫ Raum√ºbersicht:\n");		for (Room room : allRooms) { // F√ºr jedes room Objekt was den Typ Room hat und in der allRooms Arrayliste ist:			String name = room.shortDescription(); // Die String Variable "name" hat den Wert von der methode shortDescripition, die in der Klasse Room ist | diese gibt die Beschreibung zur√ºck			if (room == currentRoom) { // Wenn das room Objekt gleich der aktuelle Raum ist dann:				name += " ‚Üê du bist hier"; // Name bekommt neuen Wert name = name + " ‚Üê du bist hier";			}			System.out.println("- " + name); // Ausgabe			if (!room.getItems().isEmpty()) { // Wenn von einem der R√§ume die Item liste nicht leer ist:				for (Item item: room.getItems()) { // F√ºr jedes item Objekt vom Typ Item was in der arrayliste items ist beziehungsweise in der Methode getItems() von der Room Klasse:					System.out.println("   ‚Üí " + item); // Diese Ausgabe				}			}		}	}}